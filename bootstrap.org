* Bootstrapping esy from just OCaml, Dune and Bash utils.

** Links

https://gist.github.com/mihow/9c7f559807069a03e302605691f85572

We're trying to build esy from source without requiring itself. The
mechanism can be extended to any esy project.

** Dumping the Makefile

#+begin_src js :dir .
  let cp = require('child_process');
  let fs = require('fs');
  let path = require('path');

  let cwd;

  // Build plan variables
  let globalStorePrefix, localStore, store, project, sources;

  path = require('path');
  cwd = process.cwd();
  localStore = path.join(cwd, "_esy-store")
  store = path.join(cwd, "_esy-store")
  globalStorePrefix = path.join(cwd, "_esy-store")
  sources = path.join(cwd, "_esy-sources")
  project = cwd;

  let Package, esyBuildPlanStr, esyBuildPlan, lockFile, makeFile, Compile;
  Package = {
    nameOfLockEntry: (entry) => {
    let parts = entry.split('@');
      if (parts[0]) { return parts[0]; } else { return '@' + parts[1]; }
    }
  };

  esyBuildPlanStr = cp.execSync('esy build-plan').toString('utf-8');

  esyBuildPlan = JSON.parse(esyBuildPlanStr);

  lockFile = require(process.cwd() + '/esy.lock/index.json');
  Object.keys(lockFile);
  Package.nameOfLockEntry(lockFile.root);

  /* type rule = { target, deps, build } */
  makeFile /* list(rule) */ = [];

  Compile = {
    rule: ({target, deps, buildCommands}) => `${target}: ${deps.join(' ')}\n\t${buildCommands.map((command) => command.join(' ')).join(';\n\t')}`,
  };

  Compile.rule({
    target: 'fkkkkkkkkk`oo',
    deps: ['bar', 'baz'],
    buildCommands: [
      ['dune', 'build', '-p', 'foo'],
      ['dune', 'build', '-p', 'bar'],
    ],
  });

  // packageID as in esy's package ID

  function throwError(message) {
    throw message;
  }

  function renderVariables(str) {
    return str.replace("%{globalStorePrefix}%", globalStorePrefix).replace('%{localStore}%', localStore).replace('%{store}%', store).replace('%{project}%', project);
  }

  Env = {
    render(env) {
    return Object.keys(env).reduce((acc, key) => {
      acc[key] = renderVariables(env[key]);
      return acc;
    }, {})
    },
    toString(env) {
      return Object.keys(env).map(key => `${key}="${env[key]}"`).join(' ');
    }
  }

  function traverse(makeFile, lockFile, packageID) {
    let {dependencies} = lockFile.node[packageID] || throwError(`Package name not found: ${packageID}`);
    let packageName = Package.nameOfLockEntry(packageID);
    let buildPlan = JSON.parse(cp.execSync(`esy build-plan -p ${packageName}`).toString());
    let renderedEnv = Env.render(buildPlan.env);
    let renderedEnvStr = Env.toString(renderedEnv);
    let buildCommands = buildPlan.build.map(arg => arg.map(renderVariables)).map(args => { return ["env", "-i", "-S", renderedEnvStr].concat(args); });
    let buildsInSource = buildPlan.buildType == "in-source" || buildPlan.buildPlan == "_build";
    let curRoot = renderedEnv["cur__root"].replace(path.join(process.env['HOME'],'.esy', 'source', 'i'), sources);
    let curOriginalRoot = renderedEnv["cur__original_root"].replace(path.join(process.env['HOME'],'.esy', 'source', 'i'), sources);
    let curToplevel = renderedEnv["cur__toplevel"];
    let curTargetDir = renderedEnv["cur__target_dir"];
    let curStublibs = renderedEnv["cur__stublibs"];
    let curShare = renderedEnv["cur__share"];
    let curSbin = renderedEnv["cur__sbin"];
    let curMan = renderedEnv["cur__man"];
    let curLib = renderedEnv["cur__lib"];
    let curEtc = renderedEnv["cur__etc"];
    let curDoc = renderedEnv["cur__doc"];
    let curBin = renderedEnv["cur__bin"];
    buildCommands = [["cd", curRoot]].concat(buildCommands);
    if (buildsInSource) {
      buildCommands = [["cp", "-R", curOriginalRoot,  curRoot]].concat(buildCommands);
    } else {
      buildCommands = [["mkdir", "-p", curTargetDir]].concat(buildCommands);
    }
    buildCommands = [["mkdir", "-p", curTargetDir], ["mkdir", "-p", curStublibs], ["mkdir", "-p", curShare],
    ["mkdir", "-p", curSbin], ["mkdir", "-p", curMan], ["mkdir", "-p", curLib],
    ["mkdir", "-p", curEtc], ["mkdir", "-p", curDoc], ["mkdir", "-p", curBin]].concat(buildCommands);
    return dependencies
      .reduce((makeFile, dep) => makeFile.concat(traverse([], lockFile, dep)), makeFile)
      .concat([
	{
	  target: packageName,
	  deps: dependencies.map(Package.nameOfLockEntry),
	  buildCommands
	},
      ]);
  }

  fs.writeFileSync(
    'boot.Makefile',
    traverse([], lockFile, lockFile.root).map(Compile.rule).join('\n\n'),
  );
#+end_src

#+RESULTS:
: undefined


** Preparing the sources directory

#+begin_src sh
  mkdir -p _esy-store/3/
  esy i --cache-tarballs-path=_esy-sources
  cd _esy-sources
  for i in $(ls *.tgz);
  do
      mkdir -p ${i%.tgz};
      tar -xf ${i} -C ${i%.tgz};
  done
  mkdir -p _esy-store/3/{i,b,s}
#+end_src

#+RESULTS:

** Parsing build-plans


#+begin_src js

#+end_src


