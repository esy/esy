"use strict";(self.webpackChunksite_v_3=self.webpackChunksite_v_3||[]).push([[8652],{7011:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>d,toc:()=>r});var t=s(4848),i=s(8453);const o={id:"concepts",title:"Concepts"},a=void 0,d={id:"concepts",title:"Concepts",description:"This serves as a glossary and an overview of concepts used in esy with links to",source:"@site/../docs/concepts.md",sourceDirName:".",slug:"/concepts",permalink:"/docs/concepts",draft:!1,unlisted:!1,editUrl:"https://github.com/esy/esy/tree/master/docs/../docs/concepts.md",tags:[],version:"current",lastUpdatedBy:"prometheansacrifice",lastUpdatedAt:1726580462,formattedLastUpdatedAt:"Sep 17, 2024",frontMatter:{id:"concepts",title:"Concepts"},sidebar:"docs",previous:{title:"Using the OCaml compiler",permalink:"/docs/ocaml-compiler"},next:{title:"Project Configuration",permalink:"/docs/configuration"}},l={},r=[{value:"Project Sandbox",id:"project-sandbox",level:2},{value:"Manifest",id:"manifest",level:2},{value:"Support for esy.json",id:"support-for-esyjson",level:4},{value:"Package",id:"package",level:2},{value:"Release mode and Development mode",id:"release-mode-and-development-mode",level:2},{value:"Root package",id:"root-package",level:2},{value:"Dependency",id:"dependency",level:2},{value:"Regular dependency",id:"regular-dependency",level:2},{value:"Development time dependency",id:"development-time-dependency",level:2},{value:"Build time dependency",id:"build-time-dependency",level:2},{value:"Peer dependency",id:"peer-dependency",level:2},{value:"Solution",id:"solution",level:2},{value:"Stores",id:"stores",level:2},{value:"Sources",id:"sources",level:3},{value:"Build store",id:"build-store",level:3},{value:"Global build store",id:"global-build-store",level:4},{value:"Local build store",id:"local-build-store",level:4},{value:"Install store",id:"install-store",level:3},{value:"Package stage location",id:"package-stage-location",level:4},{value:"Release",id:"release",level:2},{value:"Additional notes",id:"additional-notes",level:2},{value:"Compiler",id:"compiler",level:3}];function c(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"This serves as a glossary and an overview of concepts used in esy with links to\ndetailed guide."}),"\n",(0,t.jsx)(n.h2,{id:"project-sandbox",children:"Project Sandbox"}),"\n",(0,t.jsxs)(n.p,{children:["A directory with a ",(0,t.jsx)(n.a,{href:"#manifest",children:"manifest"})," (usually ",(0,t.jsx)(n.code,{children:"package.json"}),")."]}),"\n",(0,t.jsxs)(n.p,{children:["Almost every ",(0,t.jsx)(n.code,{children:"esy"})," command operates in the context of a project sandbox."]}),"\n",(0,t.jsx)(n.h2,{id:"manifest",children:"Manifest"}),"\n",(0,t.jsxs)(n.p,{children:["A JSON file usually called ",(0,t.jsx)(n.code,{children:"package.json"})," which contains information about esy\npackage:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Package name and version."}),"\n",(0,t.jsx)(n.li,{children:"Dependency declarations."}),"\n",(0,t.jsx)(n.li,{children:"Commands needed to build and install package artifacts."}),"\n",(0,t.jsx)(n.li,{children:"Other metadata"}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"support-for-esyjson",children:"Support for esy.json"}),"\n",(0,t.jsxs)(n.p,{children:["Usually a manifest is represented as ",(0,t.jsx)(n.code,{children:"package.json"})," but to allow ",(0,t.jsx)(n.code,{children:"package.json"}),"\nto be used exclusively with npm, esy allows manifests to be represented as\n",(0,t.jsx)(n.code,{children:"esy.json"})," files. In the case both ",(0,t.jsx)(n.code,{children:"package.json"})," and ",(0,t.jsx)(n.code,{children:"esy.json"})," are present in\nthe sandbox esy will prefer ",(0,t.jsx)(n.code,{children:"esy.json"})," over ",(0,t.jsx)(n.code,{children:"package.json"}),"."]}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:["Note that in case of a published (on npm registry) package esy won't be able\nto access ",(0,t.jsx)(n.code,{children:"esy.json"})," and will only read metadata using npm registry API which\nis populated from ",(0,t.jsx)(n.code,{children:"package.json"})," during publish time."]}),"\n",(0,t.jsxs)(n.p,{children:["Maintainers will need to make sure they have crafted a correct ",(0,t.jsx)(n.code,{children:"package.json"}),"\nwith metadata during publish process."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"package",children:"Package"}),"\n",(0,t.jsx)(n.p,{children:"A unit of software distribution and the smallest unit which is esy operates on."}),"\n",(0,t.jsx)(n.h2,{id:"release-mode-and-development-mode",children:"Release mode and Development mode"}),"\n",(0,t.jsx)(n.p,{children:"Any package can be built in two modes - release or development."}),"\n",(0,t.jsxs)(n.p,{children:["During release, a package is built as if it were being consumed by another dependency. Only its ",(0,t.jsx)(n.code,{children:"dependencies"})," are built (not ",(0,t.jsx)(n.code,{children:"devDependencies"}),")"]}),"\n",(0,t.jsxs)(n.p,{children:["During development mode, a package (most often only the ",(0,t.jsx)(n.a,{href:"#root-package",children:"root"}),", is built along with it's ",(0,t.jsx)(n.code,{children:"devDependencies"})," with a special flag set (not important what exactly it is) to signify that a package is being built in development mode. When this flag is set, alternatives to regular configuration (like ",(0,t.jsx)(n.code,{children:"buildDev"})," instead of ",(0,t.jsx)(n.code,{children:"build"}),") are selected in the sandbox."]}),"\n",(0,t.jsx)(n.h2,{id:"root-package",children:"Root package"}),"\n",(0,t.jsxs)(n.p,{children:["Package at the root of a ",(0,t.jsx)(n.a,{href:"#sandbox",children:"sandbox"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"dependency",children:"Dependency"}),"\n",(0,t.jsx)(n.p,{children:"Any package that the root package needs to build the sandbox (either during development or releases mode)"}),"\n",(0,t.jsx)(n.h2,{id:"regular-dependency",children:"Regular dependency"}),"\n",(0,t.jsxs)(n.p,{children:["Dependencies that are required when a package is built in release mode. These are specified in the ",(0,t.jsx)(n.code,{children:"dependencies"})," field."]}),"\n",(0,t.jsxs)(n.p,{children:["Packages like ",(0,t.jsx)(n.code,{children:"@reason-native/console"})," are a good example of regular dependencies as these dependencies are required to the build a given root package. They differ from development time dependencies (like ",(0,t.jsx)(n.code,{children:"@reason-native/rely"}),") as we'll see next."]}),"\n",(0,t.jsx)(n.h2,{id:"development-time-dependency",children:"Development time dependency"}),"\n",(0,t.jsxs)(n.p,{children:["Dependencies that are required ",(0,t.jsx)(n.strong,{children:"only"})," during development mode are specified in the ",(0,t.jsx)(n.code,{children:"devDependencies"})," (similar to how yarn and npm work)"]}),"\n",(0,t.jsxs)(n.p,{children:["Good examples of dev-dependency is ",(0,t.jsx)(n.code,{children:"@opam/ocaml-lsp-server"})," or ",(0,t.jsx)(n.code,{children:"@reason-native/rely"})," as it is only required during development of the root package."]}),"\n",(0,t.jsx)(n.h2,{id:"build-time-dependency",children:"Build time dependency"}),"\n",(0,t.jsxs)(n.p,{children:["Some dependencies are needed during the build. ",(0,t.jsx)(n.code,{children:"@opam/dune"})," and autotools packages are good examples."]}),"\n",(0,t.jsxs)(n.p,{children:["Build time dependencies are meant to be specified as ",(0,t.jsx)(n.code,{children:"regular"})," dependencies as they are needed by the package dependending on it. Build time packages are better compared with runtime packages (instead of dependencies/devDependencies). Once the root package is built, build dependencies are not needed anymore by the root package. Runtime dependencies on the other hand are still needed in the sandbox for the root package to run correctly. ",(0,t.jsx)(n.code,{children:"@opam/uchar"})," is a good example of runtime package. A binary depending on it needs it installed in the sandbox when it is run."]}),"\n",(0,t.jsx)(n.h2,{id:"peer-dependency",children:"Peer dependency"}),"\n",(0,t.jsxs)(n.p,{children:["Deprecated. We now recommend ",(0,t.jsx)(n.code,{children:"resolutions"})," mechanism over peer dependencies."]}),"\n",(0,t.jsx)(n.h2,{id:"solution",children:"Solution"}),"\n",(0,t.jsx)(n.p,{children:"A result of solving dependencies for a project sandbox."}),"\n",(0,t.jsxs)(n.p,{children:["Cached as ",(0,t.jsx)(n.code,{children:"esy.lock"})," directory in the root of a project."]}),"\n",(0,t.jsx)(n.p,{children:"It is advised to commit this file to a project's repository so that the build\nenvironment is reproducible and doesn't depend on the current state of package\nregistries (either npm or opam)."}),"\n",(0,t.jsx)(n.h2,{id:"stores",children:"Stores"}),"\n",(0,t.jsx)(n.p,{children:"Esy maintains three kinds of artifacts - sources, builds and installed artfiacts - in three different locations."}),"\n",(0,t.jsx)(n.h3,{id:"sources",children:"Sources"}),"\n",(0,t.jsx)(n.p,{children:"Source entries in the esy store are source code files and the recipes that build and install them bundled together. Change any of them, and esy creates a different entry for the source of a package."}),"\n",(0,t.jsx)(n.p,{children:"If, for instance, build instructions of a package from opam are overridden (and the source files are not necessarily touched), esy places them in a different location."}),"\n",(0,t.jsx)(n.p,{children:"Conceptually, a source entry in the esy store is both its source files and its recipe."}),"\n",(0,t.jsx)(n.h3,{id:"build-store",children:"Build store"}),"\n",(0,t.jsx)(n.p,{children:"Build store is simply location where build artifacts are stored. They can be local to a project or global (so that they can be reused)."}),"\n",(0,t.jsx)(n.p,{children:"Build artifacts (object files, bytecode files etc) stored as separate entries dependending on the instructions that build and install them, environment variables present during its build and of course the sources (source code + recipe)."}),"\n",(0,t.jsx)(n.p,{children:"Change anyone of them, and esy creates a separate entry in the build store."}),"\n",(0,t.jsx)(n.h4,{id:"global-build-store",children:"Global build store"}),"\n",(0,t.jsx)(n.p,{children:"Store where the build entries common to multiple projects are stored. This can be considered a a cache too."}),"\n",(0,t.jsxs)(n.p,{children:["By default the global install store can be found at ",(0,t.jsx)(n.code,{children:"~/.esy/3/b"})]}),"\n",(0,t.jsx)(n.h4,{id:"local-build-store",children:"Local build store"}),"\n",(0,t.jsx)(n.p,{children:"Store where build entries that are relevant only to a give project are store."}),"\n",(0,t.jsxs)(n.p,{children:["By default the global install store can be found at ",(0,t.jsx)(n.code,{children:"<project root>/_esy/default/store/b/<build_id>"})]}),"\n",(0,t.jsx)(n.h3,{id:"install-store",children:"Install store"}),"\n",(0,t.jsx)(n.p,{children:"Install stores are where final, ready to be consumed, artifacts are stored. The paths (which uniquely identify them) depend on how they are built."}),"\n",(0,t.jsx)(n.p,{children:"Like build artifacts, install stores can be both local and global."}),"\n",(0,t.jsxs)(n.p,{children:["By default the global install store can be found at ",(0,t.jsx)(n.code,{children:"~/.esy/3__../i"})," and the local one can be found at ",(0,t.jsx)(n.code,{children:"<project root>/_esy/default/store/i/<build_id>"})]}),"\n",(0,t.jsx)(n.h4,{id:"package-stage-location",children:"Package stage location"}),"\n",(0,t.jsx)(n.p,{children:"As packages are built and installed, they can fail for a lot of reasons. To prevent unusable entries in the install store, packages are first installed to a staging area and only once the steps complete successfully, are they moved to the final store."}),"\n",(0,t.jsx)(n.h2,{id:"release",children:"Release"}),"\n",(0,t.jsxs)(n.p,{children:["Before a binary executable can be distributed, ",(0,t.jsx)(n.code,{children:"esy"})," can bundle runtime depedendencies together with it and install them alongside. As a proof-of-concept, Esy provides ",(0,t.jsx)(n.code,{children:"npm-release"})," command that creates a npm package that bundle the runtime binaries with a postinstalls cript that correctly installs them and updates the binaries to load the depdendencies from this install path. Check out ",(0,t.jsx)(n.a,{href:"/docs/commands#esy-npm-release",children:(0,t.jsx)(n.code,{children:"npm-release"})})," to see what that looks like."]}),"\n",(0,t.jsx)(n.h2,{id:"additional-notes",children:"Additional notes"}),"\n",(0,t.jsx)(n.h3,{id:"compiler",children:"Compiler"}),"\n",(0,t.jsxs)(n.p,{children:["Esy expects the ocaml compiler from NPM and not Opam - this is tied to how esy solves dependency constraints for opam packages. Esy begins solving the package dependency graph with OCaml compiler at the root and expects the formula version spec to be either in NPM or source form. Packages like ",(0,t.jsx)(n.code,{children:"@opam/ocaml"}),", ",(0,t.jsx)(n.code,{children:"@opam/ocaml-base-compiler"})," are not looked at while solving."]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>d});var t=s(6540);const i={},o=t.createContext(i);function a(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);