"use strict";(self.webpackChunksite_v_3=self.webpackChunksite_v_3||[]).push([[8318],{447:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>t,default:()=>p,frontMatter:()=>r,metadata:()=>c,toc:()=>d});var s=i(4848),o=i(8453);const r={id:"c-workflow",title:"Workflow for C/C++ Packages"},t=void 0,c={id:"c-workflow",title:"Workflow for C/C++ Packages",description:"esy providing a workflow for native development couldn't skip supporting C/C++",source:"@site/../docs/c-workflow.md",sourceDirName:".",slug:"/c-workflow",permalink:"/docs/c-workflow",draft:!1,unlisted:!1,editUrl:"https://github.com/esy/esy/tree/master/docs/../docs/c-workflow.md",tags:[],version:"current",lastUpdatedBy:"prometheansacrifice",lastUpdatedAt:1725276685,formattedLastUpdatedAt:"Sep 2, 2024",frontMatter:{id:"c-workflow",title:"Workflow for C/C++ Packages"},sidebar:"docs",previous:{title:"Workflow for opam Packages",permalink:"/docs/opam-workflow"},next:{title:"Offline Builds",permalink:"/docs/offline"}},l={},d=[{value:"Exposing C library with pkg-config",id:"exposing-c-library-with-pkg-config",level:2},{value:"Consuming C library with pkg-config",id:"consuming-c-library-with-pkg-config",level:2},{value:"buildsInSource: &quot;unsafe&quot;",id:"buildsinsource-unsafe",level:2}];function a(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"esy providing a workflow for native development couldn't skip supporting C/C++\npackages as C/C++ libraries/tools are so widespread."}),"\n",(0,s.jsx)(n.p,{children:"There are numerous examples of Reason/OCaml code using C/C++ code via FFI:\nbindings to libcurl, SDL, OpenGL and so on and so on."}),"\n",(0,s.jsxs)(n.p,{children:["The easiest way to expose some C/C++ code between esy packages is with\n",(0,s.jsx)(n.a,{href:"https://www.freedesktop.org/wiki/Software/pkg-config/",children:"pkg-config"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"exposing-c-library-with-pkg-config",children:"Exposing C library with pkg-config"}),"\n",(0,s.jsxs)(n.p,{children:["Let's consider a C library called ",(0,s.jsx)(n.code,{children:"dep"})," which is going to be consumed as an\n",(0,s.jsx)(n.code,{children:"dep"})," esy package."]}),"\n",(0,s.jsxs)(n.p,{children:["First we need to write ",(0,s.jsx)(n.code,{children:"dep.pc"})," file which contains pkg-config configuration\nfile for our lib."]}),"\n",(0,s.jsxs)(n.p,{children:["We do this via ",(0,s.jsx)(n.code,{children:"Makefile"})," with ",(0,s.jsx)(n.code,{children:"build"})," and ",(0,s.jsx)(n.code,{children:"install"})," targets:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'    define dep_pc\n    prefix=$(cur__install)\n    exec_prefix=$${prefix}\n    includedir=$${prefix}/lib\n    libdir=$${exec_prefix}/lib\n\n    Name: dep\n    Description: The dep library\n    Version: 1.0.0\n    Cflags: -I$${includedir}\n    Libs: -L$${libdir} -ldep\n    endef\n    export dep_pc\n\n    build:\n      ... build commands ...\n\n    install:\n      ... other install commands ...\n      echo "$$dep_pc" > $(cur__install)/lib/dep.pc\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Note that we have installed out ",(0,s.jsx)(n.code,{children:"dep.pc"})," into ",(0,s.jsx)(n.code,{children:"$cur__install/lib"}),", we need to\nupdate ",(0,s.jsx)(n.code,{children:"$PKG_CONFIG_PATH"})," with this in ",(0,s.jsx)(n.code,{children:'"esy.exportedEnv"'}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'    {\n      "name": "dep",\n      "version": "1.0.0",\n      "esy": {\n        "build": "make build",\n        "install": "make install",\n        "exportedEnv": {\n          "PKG_CONFIG_PATH": {\n            "val": "#{self.lib : $PKG_CONFIG_PATH}",\n            "scope": "global"\n          }\n        }\n      }\n    }\n'})}),"\n",(0,s.jsxs)(n.p,{children:["In the ",(0,s.jsx)(n.code,{children:"package.json"})," above ",(0,s.jsx)(n.code,{children:"#{self.lib}"})," is the same value as\n",(0,s.jsx)(n.code,{children:"$cur__install/lib"})," but represented via esy's command expression syntax."]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"NOTE"})}),"\n",(0,s.jsxs)(n.p,{children:["If you are porting some C/C++ library into esy then it is most likely this\nlibrary already has ",(0,s.jsx)(n.code,{children:"*.pc"})," file present. Then you need only to make sure you\nupdate ",(0,s.jsx)(n.code,{children:"$PKG_CONFIG_PATH"})," in the ",(0,s.jsx)(n.code,{children:"package.json"})," corresponding to the library."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"consuming-c-library-with-pkg-config",children:"Consuming C library with pkg-config"}),"\n",(0,s.jsxs)(n.p,{children:["To link a C library exposed with ",(0,s.jsx)(n.code,{children:"pkg-config"})," a project must depend on that\nlibrary and on ",(0,s.jsx)(n.code,{children:"pkg-config"})," package which is hosted on GitHub at\n",(0,s.jsx)(n.a,{href:"https://github.com/esy-packages/pkg-config",children:"esy-packages/pkg-config"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The entire ",(0,s.jsx)(n.code,{children:"package.json"})," for the project would look like this:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'    {\n      "name": "my-project",\n      "esy": {\n        "build": "make build",\n        "install": "make install"\n      },\n      "dependencies": {\n        "dep": "1.0.0",\n        "pkg-config": "esy-packages/pkg-config"\n      }\n    }\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"Makefile"})," will contain a call to ",(0,s.jsx)(n.code,{children:"pkg-config"})," to generate command line\noptions for C compiler needed to compile against a library ",(0,s.jsx)(n.code,{children:"dep"})," and link it to\nthe final executable:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-makefile",children:"build:\n\tcc $(shell pkg-config --cflags --libs dep) \\\n         -o $(cur__target_dir)/main main.c\n"})}),"\n",(0,s.jsx)(n.h2,{id:"buildsinsource-unsafe",children:'buildsInSource: "unsafe"'}),"\n",(0,s.jsxs)(n.p,{children:['C libraries that use the GNU make as their build system often "build\nin source" - ie artifacts are created alongside the source\nfiles. ',(0,s.jsx)(n.code,{children:"esy"}),"'s ",(0,s.jsx)(n.code,{children:"buildsInSource: true"})," configuration is aimed at building\nsuch libraries for the esy store - not written with incremental\ndevelopment in mind."]}),"\n",(0,s.jsxs)(n.p,{children:["This is why, when using ",(0,s.jsx)(n.code,{children:"buildsInSource: true"})," with C libraries can\nlead to long build times - as esy first copies it to build directory\nand then generates the build artifacts alongside the source tree. This\nis perfect for esy store, but slow for incremental development. This\nis particularly noticed, when for instance, one tries to use ",(0,s.jsx)(n.code,{children:"esy"})," to\nbuild Janestreet's [",(0,s.jsx)(n.code,{children:"flambda-backend"}),"][]."]}),"\n",(0,s.jsxs)(n.p,{children:["For incremental development, use ",(0,s.jsx)(n.code,{children:'buildsInSource: "unsafe"'}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["In this mode, ",(0,s.jsx)(n.code,{children:"esy"})," creates artifacts in the source tree as the\nproject's build system expects, without the copy step. The\nsubsequent build command will see the previous run's artifacts and not\nrebuild them unnecessarily. ",(0,s.jsx)(n.code,{children:"buildsInSource: true"})," would have deleted\nthe previous run and copied it again to build the package from scratch."]}),"\n",(0,s.jsx)(n.p,{children:"This is the entire workflow needed to work with C/C++ code with esy."})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>t,x:()=>c});var s=i(6540);const o={},r=s.createContext(o);function t(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:t(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);