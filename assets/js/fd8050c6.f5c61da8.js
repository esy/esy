"use strict";(self.webpackChunksite_v_3=self.webpackChunksite_v_3||[]).push([[6462],{3414:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>l,metadata:()=>o,toc:()=>c});var i=s(5893),t=s(1151);const l={id:"development",title:"Development"},r=void 0,o={id:"development",title:"Development",description:"To make changes to esy and test them locally:",source:"@site/../docs/development.md",sourceDirName:".",slug:"/development",permalink:"/docs/development",draft:!1,unlisted:!1,editUrl:"https://github.com/esy/esy/tree/master/docs/../docs/development.md",tags:[],version:"current",lastUpdatedBy:"prometheansacrifice",lastUpdatedAt:1702029753,formattedLastUpdatedAt:"Dec 8, 2023",frontMatter:{id:"development",title:"Development"},sidebar:"docs",previous:{title:"How esy works",permalink:"/docs/how-it-works"}},d={},c=[{value:"Running Tests",id:"running-tests",level:2},{value:"Issues",id:"issues",level:2},{value:"Publishing Releases",id:"publishing-releases",level:2},{value:"CI",id:"ci",level:2},{value:"EsyVersion.re",id:"esyversionre",level:3}];function a(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",...(0,t.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["To make changes to ",(0,i.jsx)(n.code,{children:"esy"})," and test them locally:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"git clone git://github.com/esy/esy.git\ncd esy\n"})}),"\n",(0,i.jsx)(n.p,{children:"And then,"}),"\n",(0,i.jsxs)(n.p,{children:["On Linux/MacOS, run newly built ",(0,i.jsx)(n.code,{children:"esy"})," executable from anywhere like ",(0,i.jsx)(n.code,{children:"PATH_TO_REPO/_build/default/bin/esy"}),".\nOn Windows, use the cmd wrapper in ",(0,i.jsx)(n.code,{children:"PATH_TO_REPO/bin/esy.cmd"}),". On Windows, esy binary needs ",(0,i.jsx)(n.a,{href:"https://github.com/esy/esy-bash",children:(0,i.jsx)(n.code,{children:"esy-bash"})}),". ",(0,i.jsx)(n.code,{children:"esy"})," distributed on NPM finds it in the node_modules, but the dev binary finds it via the ",(0,i.jsx)(n.code,{children:"ESY__ESY_BASH"})," variable in the environment."]}),"\n",(0,i.jsx)(n.h2,{id:"running-tests",children:"Running Tests"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Fast tests (no internet connection needed)"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sh",children:"yarn jest\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"2",children:["\n",(0,i.jsx)(n.li,{children:"Slow tests (needs internet connection)"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sh",children:"node ./test-e2e-slow/run-slow-tests.js\n"})}),"\n",(0,i.jsxs)(n.ol,{start:"3",children:["\n",(0,i.jsx)(n.li,{children:"Unit tests"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sh",children:"esy b dune runtest\n"})}),"\n",(0,i.jsx)(n.h2,{id:"issues",children:"Issues"}),"\n",(0,i.jsxs)(n.p,{children:["Issues are tracked at ",(0,i.jsx)(n.a,{href:"https://github.com/esy/esy",children:"esy/esy"}),"."]}),"\n",(0,i.jsx)(n.h2,{id:"publishing-releases",children:"Publishing Releases"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"esy"})," is primarily distributed via NPM (in fact, at the moment, this\nis the only distribution channel). To create an NPM tarball, one could\nsimply run,"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sh",children:"esy release\n"})}),"\n",(0,i.jsxs)(n.p,{children:["And the ",(0,i.jsx)(n.code,{children:"_release"})," folder is ready to be installed via NPM. But since\nit would contain only one platform's binaries (the machine on which it\nwas built), we combine builds from multiple platforms on the CI."]}),"\n",(0,i.jsxs)(n.p,{children:["We use ",(0,i.jsx)(n.a,{href:"https://dev.azure.com/esy-dev/esy/_build",children:"Azure Pipelines"})," for\nCI/CD. Every successful build from ",(0,i.jsx)(n.code,{children:"master"})," branch is automatically\npublished to NPM under ",(0,i.jsx)(n.code,{children:"@esy-nightly/esy"})," name. We could,"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Download the artifact directly from Azure Pipelines, or"}),"\n",(0,i.jsx)(n.li,{children:"Download the nightly npm tarball."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Once downloaded, one can update the name and version field according\nto the release."}),"\n",(0,i.jsxs)(n.p,{children:["Note, that MacOS M1 isn't available on Azure Pipelines yet. So, this\nbuild is included by building it locally, and placing the ",(0,i.jsx)(n.code,{children:"_release"}),"\nin the ",(0,i.jsx)(n.code,{children:"platform-darwin-arm64"})," folder along side other platforms."]}),"\n",(0,i.jsxs)(n.p,{children:["Release tag ",(0,i.jsx)(n.code,{children:"next"})," is used to publish preview releases."]}),"\n",(0,i.jsx)(n.h2,{id:"ci",children:"CI"}),"\n",(0,i.jsx)(n.h3,{id:"esyversionre",children:"EsyVersion.re"}),"\n",(0,i.jsxs)(n.p,{children:["We infer esy version with git. A script, ",(0,i.jsx)(n.code,{children:"version.sh"})," is present in\n",(0,i.jsx)(n.code,{children:"esy-version/"}),". This script can output a ",(0,i.jsx)(n.code,{children:"let"})," statement in OCaml or\nReason containing the version."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-sh",children:"sh ./esy-version/version.sh --reason\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Internally, it uses ",(0,i.jsx)(n.code,{children:"git describe --tags"})]}),"\n",(0,i.jsxs)(n.p,{children:["During development, it's not absolutely necessary to run this script\nbecause ",(0,i.jsx)(n.code,{children:".git/"})," is always present and Dune is configured extract\nit. This, however, is not true for CI as we develop for different\nplatforms/distribution channels. Case in point, Nix and Docker. Even,\n",(0,i.jsx)(n.code,{children:"esy release"})," copies the source tree (without ",(0,i.jsx)(n.code,{children:".git/"}),") in isolation to\nprepare the npm tarball."]}),"\n",(0,i.jsxs)(n.p,{children:["Therefore, on the CI, it's necessary to generate ",(0,i.jsx)(n.code,{children:"EsyVersion.re"})," file\ncontaining the version with the ",(0,i.jsx)(n.code,{children:"version.sh"})," script before running\nany of the build commands. You can see this in ",(0,i.jsx)(n.code,{children:"build-platform.yml"}),"\nright after the ",(0,i.jsx)(n.code,{children:"git clone"})," job."]}),"\n",(0,i.jsxs)(n.p,{children:["Note: you'll need the CI to fetch tags as it clones. By default, for\ninstance, Github Actions only shallow clones the repository, which\ndoes not fetch tags. Fetching ",(0,i.jsx)(n.code,{children:"n"})," number of commits during the shallow\nclone isn't helpful either. This is why, ",(0,i.jsx)(n.code,{children:"fetch-depth"})," is set to ",(0,i.jsx)(n.code,{children:"0"}),"\nin the Nix Github Actions workflow. (",(0,i.jsx)(n.code,{children:"nix.yml"}),")"]})]})}function h(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},1151:(e,n,s)=>{s.d(n,{Z:()=>o,a:()=>r});var i=s(7294);const t={},l=i.createContext(t);function r(e){const n=i.useContext(l);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);