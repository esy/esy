#!/usr/bin/env bash

set -e

# http://stackoverflow.com/questions/59895/can-a-bash-script-tell-what-directory-its-stored-in
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
  SCRIPTDIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$SCRIPTDIR/$SOURCE" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
done
SCRIPTDIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"

if [ -z "${ESY__SANDBOX+x}" ]; then
  export ESY__SANDBOX="$PWD"
fi
if [ -z "${ESY__PREFIX+x}" ]; then
  export ESY__PREFIX="$HOME/.esy"
fi
if [ -z "${ESY__LOCAL_STORE+x}" ]; then
  export ESY__LOCAL_STORE="$ESY__SANDBOX/node_modules/.cache/_esy/store"
fi

MAKEFILE_BUILD_EJECT_PATH="$ESY__SANDBOX/node_modules/.cache/_esy/build-eject"
BUILD_EJECT_PATH="$ESY__SANDBOX/node_modules/.cache/_esy/build"

if [ -d "$ESY__SANDBOX/node_modules" ]; then
  DEPENDENCIES_PACKAGE_JSON=$(find "$ESY__SANDBOX/node_modules" -name 'package.json' -or -name 'esy.json')
else
  DEPENDENCIES_PACKAGE_JSON=""
fi

needRebuildTarget () {
  TARGET="$1"
  NEED_REBUILD="false"

  # check if target exist
  if [ ! -f "$TARGET" ]; then
    NEED_REBUILD="true"
  else
    # check sandbox package.json
    if [ "$TARGET" -ot "$ESY__SANDBOX/package.json" ] || [ "$TARGET" -ot "$ESY__SANDBOX/esy.json" ]; then
      NEED_REBUILD="true"
    elif [ "$TARGET" -ot "$ESY__SANDBOX/esy.lock" ]; then
      NEED_REBUILD="true"
    else
      # check each dependencies' package.json
      for dep in $DEPENDENCIES_PACKAGE_JSON; do
        if [ "$TARGET" -ot "$dep" ]; then
          NEED_REBUILD="true"
          break
        fi
      done
    fi
  fi

  echo "$NEED_REBUILD"
}

callBuiltInCommand__build () {
  ensureBuildEjected
  if [ $# -eq 0 ]; then
    exec "$BUILD_EJECT_PATH/bin/build"
  else
    exec "$BUILD_EJECT_PATH/bin/build-exec" "$@"
  fi
}

callBuiltInCommand__x () {
  ensureBuildEjected --silent
  local installOutput
  set +e
  installOutput=$("$BUILD_EJECT_PATH/bin/install")
  local ret="$?"
  set -e
  if [ $ret -ne 0 ]; then
    echo "$installOutput"
    exit 1
  fi
  source "$BUILD_EJECT_PATH/bin/sandbox-env"
  shift
  # Checks if command ($1) is present available
  command -v "$1" >/dev/null 2>&1 || {
    echo >&2 "$1 command is not installed.";
    exit 1;
  }
  exec "$@"
}

ensureBuildEjected () {
  local esyArgs
  local needRebuild
  needRebuild=$(needRebuildTarget "$BUILD_EJECT_PATH/bin/build")
  if [ "$needRebuild" == "true" ]; then
    if [ "$1" == "--silent" ]; then
      (>&2 echo "info: rebuilding project, this will take some time...")
      esyArgs="$esyArgs --silent"
      shift
    fi
    node "$SCRIPTDIR/esy.js" "$esyArgs" build \
      --dependencies-only \
      --eject "$BUILD_EJECT_PATH" "$@"
    if [ $? -ne 0 ]; then
      exit 1
    fi
  fi
}

callBuiltInCommand__buildEject () {
  local needRebuild
  needRebuild=$(needRebuildTarget "$MAKEFILE_BUILD_EJECT_PATH/Makefile")
  if [ "$needRebuild" == "true" ]; then
    # Capture the error output
    # Capturing stderr is very important to prevent nodejs from setting
    # stderr to nonblocking mode
    EJECT_LOG=$(node "$SCRIPTDIR/esy.js" build-eject "$MAKEFILE_BUILD_EJECT_PATH" "$@" 2>&1)
    if [ $? -ne 0 ]; then
      echo "Failed to prepare build environment:"
      printf "%s\n" "$EJECT_LOG" >&2
      exit 1
    fi
  fi
}

callBuiltInCommand() {
	node "$SCRIPTDIR/esy.js" "$@"
}

printHelp() {
  cat <<EOF
Usage: $0 <command> [--help] [--version]

Install all dependencies and build the current project.

Avaialble subcommands:

  install               Installs packages declared in package.json.
  i

  build                 Run build commands for the project.
  b                     (as specified in "esy.build" key within package.json)

  add <package>         Add a specified package to dependencies and installs it.

  print-env             Prints esy environment on stdout.

  build-shell [path]    Drops into a shell with environment matching your
                        package's build environment. If argument is provided
                        then it should point to the package inside the current
                        sandbox â€” that will initialize build shell for that
                        specified package.

  shell                 Drops into development shell.
                        Less strict than build-shell and allows access to
                        devDependencies.

  version               Print esy version and exit

  build <command>       Run command inside the build environment.
  b <command>

  x <command>           Run command as if the package is already installed.
                        Useful for testing.

  <command>             Executes <command> as if you had executed it inside of
                        esy shell.

  help                  Show detailed help.

EOF
}

printDetailedHelp () {
  less <<EOF
$(printHelp)

Advanced commands:

  release TYPE          Create a release of type TYPE ("dev", "pack" or "bin").

  install-cache         Manage installation cache (similar to 'yarn cache'
                        command).

  import-opam           Read a provided opam file and print esy-enabled
                        package.json conents on stdout. Example:

                          esy import-opam lwt 3.0.0 ./opam

  config ls             Query esy configuration.
  config get

  export-dependencies   Export all dependencies of the current sandbox.

  export-build <id>     Exports build by <id> from global store and puts it
                        into _export/<id>.tar.gz archive.

  import-build <path>   Imports build from <path> and puts it into global store.
                        The <path> can point either to the archive produced by
                        "esy export-build" command or to the directory.

Environment variables:

  ESY__SANDBOX          Path to the current sandbox.

  ESY__PREFIX           Path to the global Esy prefix where Esy puts its
                        caches.

Configuration file (.esyrc):

  esy-import-path       Path to the directory with exported builds which will be
                        loooked up during build processes to import builds from.

  <yarn config vars>    All yarn configuration parameters are supported. They
                        only take effect for yarn-based commands such as
                        "esy install", "esy add" and so on.

EOF
}

printVersion() {
  (cd "$SCRIPTDIR/.." && node -p "require('./package.json').version")
}

callAnyCommand() {
  ensureBuildEjected --silent

  source "$BUILD_EJECT_PATH/bin/command-env"
  # Checks if command ($1) is present available
  command -v "$1" >/dev/null 2>&1 || {
  echo >&2 "$1 command is not installed.";
  exit 1;
  }
  exec "$@"
}

if [ $# -eq 0 ]
then
  callBuiltInCommand install
  callBuiltInCommand__build
elif [ $# -eq 1 ]; then
  case $1 in
    clean)
      callBuiltInCommand__buildEject
      make -j -s -f "$MAKEFILE_BUILD_EJECT_PATH/Makefile" "$1"
      ;;
    build-eject)
      callBuiltInCommand__buildEject
      ;;
    release)
      shift
      callBuiltInCommand release
      ;;
    build|b)
      shift
      callBuiltInCommand__build
      ;;
    build-ls)
      shift
      callBuiltInCommand build-ls
      ;;
    build-shell)
      shift
      callBuiltInCommand build-shell
      ;;
    import-opam)
      shift
      callBuiltInCommand import-opam
      ;;
    shell)
      ensureBuildEjected
      ENV="$BUILD_EJECT_PATH/bin/command-env" PS1="esy % " sh
      ;;
    print-env)
      ensureBuildEjected --silent
      cat "$BUILD_EJECT_PATH/bin/command-env"
      ;;
    config)
      shift
      callBuiltInCommand config
      ;;
    install|i)
      shift
      callBuiltInCommand install
      ;;
    add)
      shift
      callBuiltInCommand add "$@"
      callBuiltInCommand__build
      ;;
    install-cache)
      shift
      callBuiltInCommand install-cache
      ;;
    import|on-demand)
      shift
      callBuiltInCommand import
      ;;
    export-dependencies)
      shift
      callBuiltInCommand export-dependencies
      ;;
    export-build)
      shift
      exec "$SCRIPTDIR/esyExportBuild"
      ;;
    import-build)
      shift
      exec "$SCRIPTDIR/esyImportBuild"
      ;;
    x)
      callBuiltInCommand__x
      ;;
    version|--version|-v)
      printVersion
      ;;
    help)
      printDetailedHelp
      ;;
    --help|-h)
      printHelp
      ;;
    -*)
      echo error: unknown option "$1" >&2
      exit 1
      ;;
    *)
      callAnyCommand "$@"
      ;;
  esac
else
  case $1 in
    import-opam)
      shift
      callBuiltInCommand import-opam "$@"
      ;;
    build-eject)
      shift
      callBuiltInCommand__buildEject "$@"
      ;;
    add)
      shift
      callBuiltInCommand add "$@"
      callBuiltInCommand__build
      ;;
    build-ls)
      shift
      callBuiltInCommand build-ls "$@"
      ;;
    build-shell)
      shift
      callBuiltInCommand build-shell "$@"
      ;;
    install|i)
      shift
      callBuiltInCommand install "$@"
      ;;
    build|b)
      shift
      case "$1" in
        -*)
          callBuiltInCommand build "$@"
          ;;
        *)
          callBuiltInCommand__build "$@"
          ;;
      esac
      ;;
    install-cache)
      shift
      callBuiltInCommand install-cache "$@"
      ;;
    release)
      shift
      callBuiltInCommand release "$@"
      ;;
    import|on-demand)
      shift
      callBuiltInCommand import "$@"
      ;;
    export-dependencies)
      shift
      callBuiltInCommand export "$@"
      ;;
    export-build)
      shift
      exec "$SCRIPTDIR/esyExportBuild" "$@"
      ;;
    import-build)
      shift
      exec "$SCRIPTDIR/esyImportBuild" "$@"
      ;;
    config)
      shift
      callBuiltInCommand config "$@"
      ;;
    x)
      callBuiltInCommand__x "$@"
      ;;
    -*)
      echo Unknown option "$1" >&2
      exit 1
      ;;
    *)
      callAnyCommand "$@"
      ;;
  esac
fi

